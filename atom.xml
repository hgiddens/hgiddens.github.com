<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Robotines]]></title>
  <link href="http://blog.robotines.co.nz/atom.xml" rel="self"/>
  <link href="http://blog.robotines.co.nz/"/>
  <updated>2013-10-27T21:49:57+11:00</updated>
  <id>http://blog.robotines.co.nz/</id>
  <author>
    <name><![CDATA[Huw Giddens]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lexical and dynamic scoping]]></title>
    <link href="http://blog.robotines.co.nz/blog/2013/10/27/lexical-and-dynamic-scoping/"/>
    <updated>2013-10-27T19:30:00+11:00</updated>
    <id>http://blog.robotines.co.nz/blog/2013/10/27/lexical-and-dynamic-scoping</id>
    <content type="html"><![CDATA[<p>A discussion at work on Friday evolved into how some language features were reminiscent of monads – for example, Objective‐C&#8217;s handling of <code>nil</code> is similar to language level support for the maybe monad – and I noted I felt some similarity between the reader monad and how some languages use dynamically scoped variables. This then led to a fun digression about what dynamic scoping (AKA dynamic binding) might be, and me promising to write a quick blog post.</p>

<h2>Lexical scoping</h2>

<p>Before looking at dynamic scoping let&#8217;s look again at lexical scoping. Lexical scoping is the scoping that we&#8217;re used to from languages like Javascript, Ruby, Scheme, Java, <em>et al</em>. It&#8217;s very common and what most people are used to, it&#8217;s what makes closures work, and it&#8217;s where free variables in functions are bound based on the defining environment. For example, in Scheme (a lexically-scoped Lisp):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">outer</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">1</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">x</span><span class="p">)))</span>
</span><span class='line'><span class="p">((</span><span class="nf">outer</span><span class="p">))</span> <span class="c1">;; returns 1</span>
</span></code></pre></td></tr></table></div></figure>


<p>There&#8217;s no value for <code>x</code> bound when <code>outer</code> is called, but <code>1</code> is still returned because the definition of the inner function captures the value of <code>x</code> at the definition site.</p>

<h2>Dynamic scoping</h2>

<p>In contrast, consider the equivalent in Emacs Lisp (which is dynamically-scoped by default, although as of 24.3 <a href="http://www.emacswiki.org/emacs/LexicalBinding">Emacs also supports lexical scoping</a>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='common-lisp'><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">outer</span> <span class="p">()</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="nv">x</span><span class="p">)))</span>
</span><span class='line'><span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nv">outer</span><span class="p">))</span> <span class="c1">;; Lisp error: (void-variable x)</span>
</span></code></pre></td></tr></table></div></figure>


<p>We get an error here because, even though <code>x</code> was bound when the inner function was defined, it was unbound when it was called. On the other hand, though, we can write the following:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='common-lisp'><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">outer</span> <span class="p">()</span> <span class="nv">x</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">outer</span><span class="p">))</span> <span class="c1">;; 1</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here, we&#8217;re defining <code>outer</code> in a context where <code>x</code> is unbound, but everything&#8217;s fine because when we call <code>outer</code> we <em>do</em> have <code>x</code> bound to <code>1</code>.</p>

<h4>Languages with some form of dynamic scoping</h4>

<ul>
<li>Many Lisps have support for dynamic scoping to some extent. Special variables in Common Lisp are bound dynamically, top level vars in Clojure <em>can</em> be dynamically bound via <code>binding</code>, and Emacs Lisp is still dynamic by default even though it now supports lexical scoping.</li>
<li>Perl <code>our</code> variables can by dynamically rebound via <code>local</code>.</li>
<li>TeX is dynamically scoped.</li>
</ul>


<h2>Determining if lexical or dynamic scoping is in effect</h2>

<p>It&#8217;s simple to craft an expression that will evaluate differently based on lexical or dynamic scoping being in effect, and this can be used in languages that support both to determine which is currently being used:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='common-lisp'><span class='line'><span class="c1">;; In Emacs Lisp, the second argument to eval, if true, means to use</span>
</span><span class='line'><span class="c1">;; lexical scoping.</span>
</span><span class='line'><span class="p">(</span><span class="nb">eval</span> <span class="o">&#39;</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">scope</span> <span class="ss">&#39;dynamic</span><span class="p">))</span>
</span><span class='line'>         <span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">scope</span> <span class="ss">&#39;lexical</span><span class="p">))</span>
</span><span class='line'>                    <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="nv">scope</span><span class="p">))))</span>
</span><span class='line'>      <span class="no">nil</span><span class="p">)</span> <span class="c1">;; dynamic</span>
</span><span class='line'><span class="p">(</span><span class="nb">eval</span> <span class="o">&#39;</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">scope</span> <span class="ss">&#39;dynamic</span><span class="p">))</span>
</span><span class='line'>         <span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">scope</span> <span class="ss">&#39;lexical</span><span class="p">))</span>
</span><span class='line'>                    <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="nv">scope</span><span class="p">))))</span>
</span><span class='line'>      <span class="no">t</span><span class="p">)</span> <span class="c1">;; lexical</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Scoping implementation in a simple Lisp interpreter</h2>

<blockquote><p>Literature about Lisp rarely resists that narcissistic pleasure of describing Lisp in Lisp. – Lisp in Small Pieces</p></blockquote>

<p>The first chapter of <a href="http://www.amazon.com/Lisp-Small-Pieces-Christian-Queinnec/dp/0521545668">Lisp in Small Pieces</a> deals with implementing a simple interpreter for a Lisp. An even more simplified version of that interpreter (written in Guile Scheme, and implementing a Lisp-1 similar to Scheme) follows.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">env</span><span class="o">.</span><span class="nv">init</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">lookup</span> <span class="nv">var</span> <span class="nv">env</span><span class="p">)</span> <span class="c1">;; find variable in an environment</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">env</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">caar </span><span class="nv">env</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span>
</span><span class='line'>          <span class="p">(</span><span class="nb">cdar </span><span class="nv">env</span><span class="p">)</span>
</span><span class='line'>          <span class="p">(</span><span class="nf">lookup</span> <span class="nv">var</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">env</span><span class="p">)))</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">error</span> <span class="s">&quot;No such binding&quot;</span> <span class="nv">var</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">eprogn</span> <span class="nv">exps</span> <span class="nv">env</span><span class="p">)</span> <span class="c1">;; eval expressions in an environment, return last</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">exps</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">pair? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">exps</span><span class="p">))</span>
</span><span class='line'>          <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="nf">evaluate</span> <span class="p">(</span><span class="nb">car </span><span class="nv">exps</span><span class="p">)</span> <span class="nv">env</span><span class="p">)</span>
</span><span class='line'>                 <span class="p">(</span><span class="nf">eprogn</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">exps</span><span class="p">)</span> <span class="nv">env</span><span class="p">))</span>
</span><span class='line'>          <span class="p">(</span><span class="nf">evaluate</span> <span class="p">(</span><span class="nb">car </span><span class="nv">exps</span><span class="p">)</span> <span class="nv">env</span><span class="p">))</span>
</span><span class='line'>      <span class="o">&#39;</span><span class="p">()))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">evlis</span> <span class="nv">exps</span> <span class="nv">env</span><span class="p">)</span> <span class="c1">;; eval expressions in an environment, return all</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">exps</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">evaluate</span> <span class="p">(</span><span class="nb">car </span><span class="nv">exps</span><span class="p">)</span> <span class="nv">env</span><span class="p">)</span>
</span><span class='line'>            <span class="p">(</span><span class="nf">evlis</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">exps</span><span class="p">)</span> <span class="nv">env</span><span class="p">))</span>
</span><span class='line'>      <span class="o">&#39;</span><span class="p">()))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">extend</span> <span class="nv">env</span> <span class="nv">variables</span> <span class="nv">values</span><span class="p">)</span> <span class="c1">;; extend environment with vars with values</span>
</span><span class='line'>  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">pair? </span><span class="nv">variables</span><span class="p">)</span>
</span><span class='line'>         <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">values</span><span class="p">)</span>
</span><span class='line'>             <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">variables</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">values</span><span class="p">))</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">extend</span> <span class="nv">env</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">variables</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">values</span><span class="p">)))</span>
</span><span class='line'>             <span class="p">(</span><span class="nf">error</span> <span class="s">&quot;Too few values&quot;</span><span class="p">)))</span>
</span><span class='line'>        <span class="p">((</span><span class="nb">null? </span><span class="nv">variables</span><span class="p">)</span>
</span><span class='line'>         <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">values</span><span class="p">)</span>
</span><span class='line'>             <span class="nv">env</span>
</span><span class='line'>             <span class="p">(</span><span class="nf">error</span> <span class="s">&quot;Too many values&quot;</span><span class="p">)))</span>
</span><span class='line'>        <span class="p">((</span><span class="nb">symbol? </span><span class="nv">variables</span><span class="p">)</span>
</span><span class='line'>         <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="nv">variables</span> <span class="nv">values</span><span class="p">)</span> <span class="nv">env</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">invoke</span> <span class="nv">fn</span> <span class="nv">args</span> <span class="nv">env</span><span class="p">)</span> <span class="c1">;; invoke fn with arguments in an environment</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">procedure? </span><span class="nv">fn</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">fn</span> <span class="nv">args</span> <span class="nv">env</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">error</span> <span class="s">&quot;Not a function&quot;</span> <span class="nv">fn</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-function</span> <span class="nv">variables</span> <span class="nv">body</span> <span class="nv">env</span><span class="o">.</span><span class="nv">definition</span><span class="p">)</span> <span class="c1">;; create new function</span>
</span><span class='line'>  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nb">values </span><span class="nv">env</span><span class="o">.</span><span class="nv">current</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">eprogn</span> <span class="nv">body</span> <span class="p">(</span><span class="nf">extend</span> <span class="nv">env</span><span class="o">.</span><span class="nv">current</span> <span class="nv">variables</span> <span class="nv">values</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">evaluate</span> <span class="nv">exp</span> <span class="nv">env</span><span class="p">)</span> <span class="c1">;; evaluate an expression in an environment</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">exp</span><span class="p">))</span> <span class="c1">;; (atom? exp)</span>
</span><span class='line'>      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">symbol? </span><span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nf">lookup</span> <span class="nv">exp</span> <span class="nv">env</span><span class="p">)</span> <span class="nv">exp</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="k">case </span><span class="p">(</span><span class="nb">car </span><span class="nv">exp</span><span class="p">)</span>
</span><span class='line'>        <span class="p">((</span><span class="nf">quote</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">exp</span><span class="p">))</span>
</span><span class='line'>        <span class="p">((</span><span class="nf">lambda</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-function</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nb">cddr </span><span class="nv">exp</span><span class="p">)</span> <span class="nv">env</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">invoke</span> <span class="p">(</span><span class="nf">evaluate</span> <span class="p">(</span><span class="nb">car </span><span class="nv">exp</span><span class="p">)</span> <span class="nv">env</span><span class="p">)</span>
</span><span class='line'>                      <span class="p">(</span><span class="nf">evlis</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">exp</span><span class="p">)</span> <span class="nv">env</span><span class="p">)</span>
</span><span class='line'>                      <span class="nv">env</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This gives us a language where we can define functions, apply them, and not much else, but it&#8217;s sufficient for the purposes of demonstration. This is a dynamically scoped Lisp, and it stores the environment (all currently bound variables, and their values) as a list of variable-value pairs. The part of the code that makes this the case is <code>make-function</code> (repeated here):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='common-lisp'><span class='line'><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">make-function</span> <span class="nv">variables</span> <span class="nv">body</span> <span class="nv">env.definition</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">env.current</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nv">eprogn</span> <span class="nv">body</span> <span class="p">(</span><span class="nv">extend</span> <span class="nv">env.current</span> <span class="nv">variables</span> <span class="nb">values</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This creates a new function, with argument variables passed in <code>variables</code>, the function body in <code>body</code>, and the environment at the point of definition in <code>env.definition</code>. The new function – which will eventually be called by <code>invoke</code> – takes a list of argument values in <code>values</code> and the environment at the point of invocation in <code>env.current</code>. The body is evaluated by <code>eprogn</code> in an environment that is the enviroment at the point of invocation extended by the arguments, and it&#8217;s this that makes it dynamically scoped.</p>

<h4>Aside: <code>let</code> as <code>lambda</code></h4>

<p>Our little language doesn&#8217;t have <code>let</code>, so we can&#8217;t directly use our test expression from above to verify that we have the scope we believe we do. However, <code>let</code> can be implemented in terms of <code>lambda</code> in the following way (incidentally, this is the same trick as is used in JavaScript to, for instance, have variables isolated to a loop body):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="nv">y</span><span class="p">))</span>
</span><span class='line'>  <span class="nv">z</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; can be expressed as</span>
</span><span class='line'><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">z</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Using this, we can verify our little language is, indeed, dynamically scoped:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nf">evaluate</span> <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">scope</span><span class="p">)</span>
</span><span class='line'>             <span class="p">(((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">scope</span><span class="p">)</span>
</span><span class='line'>                 <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">scope</span><span class="p">))</span>
</span><span class='line'>               <span class="p">(</span><span class="k">quote </span><span class="nv">lexical</span><span class="p">))))</span>
</span><span class='line'>           <span class="p">(</span><span class="k">quote </span><span class="nv">dynamic</span><span class="p">)))</span> <span class="c1">;; dynamic</span>
</span></code></pre></td></tr></table></div></figure>


<h4>So what about lexical scoping</h4>

<p>This is the cool bit. Because it&#8217;s just our <code>make-function</code> definition that makes the language dynamically scoped, if we want a lexically scoped language instead, we just have to change it to evaluate the function body in an extension of the <em>definition</em> enviroment rather than the <em>invocation</em> environment:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-function</span> <span class="nv">variables</span> <span class="nv">body</span> <span class="nv">env</span><span class="o">.</span><span class="nv">definition</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nb">values </span><span class="nv">env</span><span class="o">.</span><span class="nv">current</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">eprogn</span> <span class="nv">body</span> <span class="p">(</span><span class="nf">extend</span> <span class="nv">env</span><span class="o">.</span><span class="nv">definition</span> <span class="nv">variables</span> <span class="nv">values</span><span class="p">))))</span>
</span><span class='line'><span class="c1">;; And with the above definition</span>
</span><span class='line'><span class="p">(</span><span class="nf">evaluate</span> <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">scope</span><span class="p">)</span>
</span><span class='line'>             <span class="p">(((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">scope</span><span class="p">)</span>
</span><span class='line'>                 <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">scope</span><span class="p">))</span>
</span><span class='line'>               <span class="p">(</span><span class="k">quote </span><span class="nv">lexical</span><span class="p">))))</span>
</span><span class='line'>           <span class="p">(</span><span class="k">quote </span><span class="nv">dynamic</span><span class="p">)))</span> <span class="c1">;; lexical    </span>
</span></code></pre></td></tr></table></div></figure>


<h2>More reading</h2>

<ul>
<li><a href="http://www.schemers.org/Documents/Standards/R5RS/">R5RS</a> – an older version of the Scheme spec</li>
<li><a href="ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-379.pdf">Lambda: The Ultimate Declarative</a></li>
<li><a href="http://en.wikipedia.org/wiki/Scope_(computer_science)">Scope (computer science) Wikipedia article</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Function composition]]></title>
    <link href="http://blog.robotines.co.nz/blog/2012/11/29/function-composition/"/>
    <updated>2012-11-29T15:27:00+11:00</updated>
    <id>http://blog.robotines.co.nz/blog/2012/11/29/function-composition</id>
    <content type="html"><![CDATA[<p>Today, I found myself wanting to compose two methods:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// What I had</span>
</span><span class='line'><span class="k">def</span> <span class="n">failureToEvent</span><span class="o">(</span><span class="n">failure</span><span class="k">:</span> <span class="kt">Failure</span><span class="o">)</span><span class="k">:</span> <span class="kt">Event</span>
</span><span class='line'><span class="k">def</span> <span class="n">publish</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Event</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// What I needed</span>
</span><span class='line'><span class="k">val</span> <span class="n">composed</span><span class="k">:</span> <span class="kt">Failure</span> <span class="o">=&gt;</span> <span class="nc">Unit</span>
</span></code></pre></td></tr></table></div></figure>


<p>Manually writing a function that is the composition of these two is easy enough, but this was a pattern that was repeating itself all over the place; I wanted to be able to define these composed functions inline. Fortunately, composing two functions like this is extremely simple:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">failureToEvent</span> <span class="k">_</span><span class="o">)</span> <span class="n">andThen</span> <span class="n">publish</span>
</span><span class='line'><span class="n">res0</span><span class="k">:</span> <span class="kt">Failure</span> <span class="o">=&gt;</span> <span class="nc">Unit</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Fantastic!</p>

<h2>Mission accomplished?</h2>

<p>This works well enough, but I discovered some cases where things were a little more complicated:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// What I had</span>
</span><span class='line'><span class="k">def</span> <span class="n">failureToOptionalEvent</span><span class="o">(</span><span class="n">failure</span><span class="k">:</span> <span class="kt">Failure</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Event</span><span class="o">]</span>
</span><span class='line'><span class="k">def</span> <span class="n">publish</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Event</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// What I was willing to accept</span>
</span><span class='line'><span class="k">val</span> <span class="n">composed</span><span class="k">:</span> <span class="kt">Failure</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>I had the same publish method, but now our failure to event transformation returns an option, stopping us composing things as easily as before. Salvation was at hand, though: I recalled from <a href="http://learnyouahaskell.com">Learn You A Haskell</a> that there&#8217;s a function <code>fmap</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">fmap</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>This basically means that <code>fmap</code> is a function taking as an argument a function from some type <code>a</code> to some type <code>b</code> (the <code>a -&gt; b</code> part) and returns a function (<code>f a -&gt; f b</code>) which is the original function “lifted” into some functor (<code>Functor f</code> – a functor can be thought of as a type that you can map over; as you might expect, LYAH has <a href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass">an excellent introduction</a>). After some digging through Scalaz 7, I found an analogue I could use:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scalaz._</span><span class="o">,</span> <span class="nc">Scalaz</span><span class="o">.</span><span class="k">_</span>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">failureToOptionalEvent</span> <span class="k">_</span><span class="o">).</span><span class="n">andThen</span><span class="o">(</span><span class="n">implicitly</span><span class="o">[</span><span class="kt">Functor</span><span class="o">[</span><span class="kt">Option</span><span class="o">]].</span><span class="n">lift</span><span class="o">(</span><span class="n">publish</span><span class="o">))</span>
</span><span class='line'><span class="n">res1</span><span class="k">:</span> <span class="kt">Failure</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>There is quite a bit of boilerplate though. Scalaz does have special syntax for lifting functions, but <a href="http://stackoverflow.com/questions/13507202/how-to-use-lift-from-tofunctorops">I couldn&#8217;t make it work</a>; fortunately it&#8217;s easy enough to write our own equivalent of the <code>lift</code> method here that will work for us (courtesy of Travis Brown):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">MyFunction1Syntax</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">R</span><span class="o">]</span> <span class="nc">extends</span> <span class="n">syntax</span><span class="o">.</span><span class="nc">Ops</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">R</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">fmap</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">scalaz.Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">=</span> <span class="n">F</span> <span class="n">lift</span> <span class="n">self</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">implicit</span> <span class="k">def</span> <span class="n">toMyFunction1Syntax</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">R</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">R</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">MyFunction1Syntax</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">R</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">self</span> <span class="k">=</span> <span class="n">f</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">failureToOptionalEvent</span> <span class="k">_</span><span class="o">).</span><span class="n">andThen</span><span class="o">((</span><span class="n">publish</span> <span class="k">_</span><span class="o">).</span><span class="n">fmap</span><span class="o">[</span><span class="kt">Option</span><span class="o">])</span>
</span><span class='line'><span class="n">res2</span><span class="k">:</span> <span class="kt">Failure</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>More than meets the eye</h2>

<p>This works perfectly well, but I was curious if there was a better way to do this – or at least, a way that didn&#8217;t involve replicating chunks of Scalaz. After some thought, it occurred to me that since functions and options are monads, we can use monad transformers here! <a href="http://en.wikibooks.org/wiki/Haskell/Monad_transformers">Monad transformers</a> are a way of layering multiple monads on top of each other to create a “monad stack”; the resulting monad transformer is itself a monad which combines the effects of its constituent monads in order. For example, if we have a <code>List[Option[Int]]</code>, we can use the <code>OptionT</code> monad transformer to map a function <code>Int =&gt; Int</code> over the transformed instance (the call to <code>run</code> is to extract the value from the transformer instance):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">OptionT</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mf">1.</span><span class="n">some</span><span class="o">,</span> <span class="mf">2.</span><span class="n">some</span><span class="o">,</span> <span class="mf">3.</span><span class="n">some</span><span class="o">,</span> <span class="nc">None</span><span class="o">)).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">run</span>
</span><span class='line'><span class="n">res3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">4</span><span class="o">),</span> <span class="nc">None</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>So in much the same way, because functions are monads of their return type we should be able to use <code>OptionT</code> to map <code>publish</code> over the transformed instance:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">OptionT</span><span class="o">(</span><span class="n">failureToOptionalEvent</span> <span class="k">_</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">publish</span><span class="o">).</span><span class="n">run</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">23</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">no</span> <span class="k">type</span> <span class="kt">parameters</span> <span class="kt">for</span> <span class="kt">method</span> <span class="kt">apply:</span> <span class="o">(</span><span class="kt">run:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="n">scalaz</span><span class="o">.</span><span class="nc">OptionT</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span> <span class="n">in</span> <span class="k">object</span> <span class="nc">OptionT</span> <span class="n">exist</span> <span class="n">so</span> <span class="n">that</span> <span class="n">it</span> <span class="n">can</span> <span class="n">be</span> <span class="n">applied</span> <span class="n">to</span> <span class="n">arguments</span> <span class="o">(</span><span class="nc">Failure</span> <span class="k">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Event</span><span class="o">])</span>
</span><span class='line'> <span class="o">---</span> <span class="n">because</span> <span class="o">---</span>
</span><span class='line'><span class="n">argument</span> <span class="n">expression</span><span class="-Symbol">&#39;s</span> <span class="k">type</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">compatible</span> <span class="kt">with</span> <span class="kt">formal</span> <span class="kt">parameter</span> <span class="k">type</span><span class="o">;</span>
</span><span class='line'> <span class="n">found</span>   <span class="k">:</span> <span class="kt">Failure</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Event</span><span class="o">]</span>
</span><span class='line'> <span class="n">required</span><span class="k">:</span> <span class="kt">?F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">?A</span><span class="o">]]</span>
</span><span class='line'>              <span class="nc">OptionT</span><span class="o">(</span><span class="n">failureToOptionalEvent</span> <span class="k">_</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">publish</span><span class="o">).</span><span class="n">run</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ugh. This is Scala&#8217;s way of telling us that we&#8217;ve asked too much of type inference; once you get past a single generic parameter this crops up with distressing frequency. We could fix this by explicitly specifying the type parameters, but I don&#8217;t like doing this; you&#8217;re faced with either an explosion of little type aliases (e.g., <code>type IntTo[+A] = Int =&gt; A</code>) or the Lovecraftian horror that is the type lambda syntax. What I instead did was add a <code>.optionT</code> to appropriate function instances:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">ExtraFunction1Ops</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="nc">extends</span> <span class="n">syntax</span><span class="o">.</span><span class="nc">Ops</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">optionT</span><span class="o">[</span><span class="kt">C</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">B</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">C</span><span class="o">])</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">OptionT</span><span class="o">[({</span> <span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">+α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">α</span> <span class="o">})</span><span class="k">#</span><span class="kt">λ</span>, <span class="kt">C</span><span class="o">](</span><span class="n">self</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">ev</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">implicit</span> <span class="k">def</span> <span class="n">function1AsExtraFunction1Ops</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fn</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">IndraFunction1Ops</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">self</span> <span class="k">=</span> <span class="n">fn</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The definition of the <code>optionT</code> method probably warrants discussion:</p>

<ul>
<li>the trait <code>ExtraFunction1Ops</code> is adding operations to instances of <code>A =&gt; B</code>; however, <code>.optionT</code> should only be callable on instances where <code>B</code> is an option of something. The implicit argument ensures that this is so: there will be an in‐scope implicit of type <code>B &lt;:&lt; Option[C]</code> iff <code>B</code> is, in fact, some subtype of <code>Option[C]</code>.</li>
<li><code>C</code> is an unconstrained generic parameter; we need this because we have to provide it to <code>OptionT.apply</code>.</li>
<li>The horrible type lambda <code>({ type λ[+α] = A =&gt; α })#λ</code> is required because <code>OptionT</code>&#8217;s first type parameter needs to be the type constructor for the outer monad; while <code>Function1</code>&#8217;s type constructor is binary, the type constructor we provide to <code>OptionT</code> <em>must</em> be unary, and so we use the type lambda to constrain the first type parameter of <code>Function1</code> to <code>A</code>.</li>
<li>Finally, we have to map our <code>ev</code>, our implicit type evidence argument, over the function; this simply converts the signature of <code>self</code> from <code>A =&gt; B</code> to <code>A =&gt; Option[C]</code>.</li>
</ul>


<p>So to recap, initially we had <code>(failureToEvent _) andThen publish</code>. For unary functions, <code>andThen</code> is identical to <code>map</code>, so we can rewrite this as <code>(failureToEvent _).map(publish)</code>. And as for our functions from a failure to an optional event?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">failureToOptionalEvent</span> <span class="k">_</span><span class="o">).</span><span class="n">optionT</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">publish</span><span class="o">).</span><span class="n">run</span>
</span><span class='line'><span class="n">res4</span><span class="k">:</span> <span class="kt">Failure</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Success.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Combining predicates in Scala with Scalaz]]></title>
    <link href="http://blog.robotines.co.nz/blog/2012/11/12/combining-predicates-in-scala-with-scalaz/"/>
    <updated>2012-11-12T13:04:00+11:00</updated>
    <id>http://blog.robotines.co.nz/blog/2012/11/12/combining-predicates-in-scala-with-scalaz</id>
    <content type="html"><![CDATA[<p>Recently I was catching up on some Scala programming blogs when I found <a href="http://timepit.eu/~frank/blog/2012/08/combining_predicates_in_scala/">a post about combining predicates</a>. I&#8217;d been wondering about this myself. I find it incredibly useful to be able to simply combine predicates; I find it quite inelegant to write code like the following:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// Given</span>
</span><span class='line'><span class="k">trait</span> <span class="nc">Request</span> <span class="o">{</span> <span class="k">def</span> <span class="n">path</span><span class="k">:</span> <span class="kt">String</span> <span class="o">}</span>
</span><span class='line'><span class="k">val</span> <span class="n">isAssetPath</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span>
</span><span class='line'><span class="k">val</span> <span class="n">isMonitoringPath</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">ignorePath</span><span class="o">(</span><span class="n">request</span><span class="k">:</span> <span class="kt">Request</span><span class="o">)</span> <span class="k">=</span> <span class="n">isAssetPath</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="n">path</span><span class="o">)</span> <span class="o">||</span> <span class="n">isMonitoringPath</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="n">path</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>I had, however, settled on manually combining them as above, and moved on. However, since then I&#8217;ve started trying to get my head around typeclass‐oriented functional programming in general and <a href="https://github.com/scalaz/scalaz">Scalaz 7</a> in particular, and decided to see if that offered a nice solution.</p>

<h2>Combining booleans</h2>

<p>I knew already that Scalaz gives us a nice, generic way to combine booleans: by treating them as monoids. Monoids are a very simple concept <a href="http://en.wikibooks.org/wiki/Haskell/Monoids">that the Haskell Wikibook defines rather nicely</a>:</p>

<blockquote><p>[A] monoid is a data type with an associative operation which combines two elements and a “zero” value which acts as a neutral element for the operation.</p></blockquote>

<p>The sum monoid for integers is an easy one to consider. The combining operation used is addition, and the zero value is zero (the <code>⊹</code> operator below is Scalaz syntax for the append operation; it has an ASCII equivalent of <code>|+|</code>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">⊹</span> <span class="mi">2</span>
</span><span class='line'><span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<p>For booleans, it&#8217;s a little trickier: there are two common monoids, representing conjunction (<code>&amp;&amp;</code>, with <code>true</code> as the zero) and disjunction (<code>||</code>, with <code>false</code>). Because neither of these makes more sense than the other as a “default” boolean monoid, Scalaz doesn&#8217;t place either in the implicit scope; we have to do this ourselves with the appropriate one (as demonstrated by the conjunction example below) or alternatively use the monoid object explicitly (as demonstrated with the disjunction):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">isDivisibleBy13</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="k">_</span> <span class="o">%</span> <span class="mi">13</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'><span class="k">val</span> <span class="n">isPalindrome</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">x</span><span class="o">.</span><span class="n">toString</span><span class="o">;</span> <span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">reverse</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">std.anyVal.booleanInstance.</span><span class="o">{</span><span class="n">conjunction</span><span class="o">,</span> <span class="n">disjunction</span><span class="o">}</span>
</span><span class='line'><span class="k">import</span> <span class="nn">std.anyVal.booleanInstance.</span><span class="o">{</span><span class="n">conjunction</span><span class="o">,</span> <span class="n">disjunction</span><span class="o">}</span>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="o">{</span> <span class="k">implicit</span> <span class="k">val</span> <span class="n">M</span> <span class="k">=</span> <span class="n">conjunction</span><span class="o">;</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="mi">13</span><span class="o">)</span> <span class="o">⊹</span> <span class="n">isDivisibleBy13</span><span class="o">(</span><span class="mi">13</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'><span class="n">res1</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="n">disjunction</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">isPalindrome</span><span class="o">(</span><span class="mi">13</span><span class="o">),</span> <span class="n">isDivisibleBy13</span><span class="o">(</span><span class="mi">13</span><span class="o">))</span>
</span><span class='line'><span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</span></code></pre></td></tr></table></div></figure>


<p>This allows us to combine boolean values; however, we want to combine functions that return boolean values. Can we use monoids to do so?</p>

<h2>Oh no, not monads</h2>

<p>The first thing I tried was using monads. Monads (again, <a href="http://en.wikibooks.org/wiki/Haskell/Monads">described nicely by the Haskell Wikibook</a> but even more nicely by the wonderful <a href="http://learnyouahaskell.com">Learn You A Haskell</a>) are a way of performing operations on values subject to some context – for example, in the case of the Option monad, the context is that the value might not be present.</p>

<p>Monads are helpful here because functions are monads in their result type (which is to say that a value of type <code>Int =&gt; String</code> is a <code>Monad[String]</code>, in the same way that <code>Some("string")</code> is). Using the function monad seems to allow us to perform operations on the results of functions before they&#8217;re called: instead of getting the result directly, we instead get a new function back performing our desired computation. This seems to work nicely:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">combine</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">M</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">ll</span> <span class="k">&lt;-</span> <span class="n">l</span>
</span><span class='line'>    <span class="n">rr</span> <span class="k">&lt;-</span> <span class="n">r</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">yield</span> <span class="n">ll</span> <span class="o">⊹</span> <span class="n">rr</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="n">combine</span><span class="o">(</span><span class="n">isPalindrome</span><span class="o">,</span> <span class="n">isDivisibleBy13</span><span class="o">)(</span><span class="n">conjunction</span><span class="o">)(</span><span class="mi">13</span><span class="o">)</span>
</span><span class='line'><span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</span></code></pre></td></tr></table></div></figure>


<p>However, there is a problem:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">alas</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">&quot;alas&quot;</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="o">{</span> <span class="k">implicit</span> <span class="k">val</span> <span class="n">M</span> <span class="k">=</span> <span class="n">disjunction</span><span class="o">;</span> <span class="n">isDivisibleBy13</span><span class="o">(</span><span class="mi">13</span><span class="o">)</span> <span class="o">⊹</span> <span class="n">alas</span><span class="o">(</span><span class="mi">13</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'><span class="n">res4</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="n">combine</span><span class="o">(</span><span class="n">isDivisibleBy13</span><span class="o">,</span> <span class="n">alas</span><span class="o">)(</span><span class="n">disjunction</span><span class="o">)(</span><span class="mi">13</span><span class="o">)</span>
</span><span class='line'><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">RuntimeException</span><span class="k">:</span> <span class="kt">alas</span>
</span></code></pre></td></tr></table></div></figure>


<p>Both <code>&amp;&amp;</code> and <code>||</code> will avoid evaluating their second argument if they can determine the result from the first alone; this behaviour is known as <a href="http://en.wikipedia.org/wiki/Short-circuit_evaluation">short‐circuiting</a>. But our <code>combine</code> function doesn&#8217;t short‐circuit, even though it receives its second argument by name (which allows us to avoid evaluating it).</p>

<h2>Regaining short‐circuiting</h2>

<p>This loss of short‐circuiting is especially vexing because <code>⊹</code> for booleans <em>does</em> short‐circuit. The problem is that in our for comprehension, by the time we get around to plugging our values (<code>ll</code> and <code>rr</code>) into <code>⊹</code>, they have of course been evaluated. I was at a loss as to how to solve this until I discovered that functions returning values that are monoids <em>are themselves</em> monoids. This lets us use the <code>⊹</code> function directly on our predicates, avoiding the over‐eager evaluation we encountered:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">combine2</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">M</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">l</span> <span class="o">⊹</span> <span class="n">r</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="n">combine2</span><span class="o">(</span><span class="n">isDivisibleBy13</span><span class="o">,</span> <span class="n">alas</span><span class="o">)(</span><span class="n">disjunction</span><span class="o">)(</span><span class="mi">13</span><span class="o">)</span>
</span><span class='line'><span class="n">res5</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Generalising</h2>

<p>So, now we&#8217;ve got a working function that we can use to combine two predicates. Generalising this to an arbitrary number of predicates is straightforward: the nullary ‘combine’ returns the zero of the monoid, and higher arities can be recursively defined by appending the first value on the combination of the remainder:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">recursiveCombination</span><span class="o">(</span><span class="n">predicates</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span> <span class="k">=&gt;</span> <span class="kt">Boolean</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">M</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">predicates</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="n">tail</span> <span class="k">=&gt;</span> <span class="n">head</span> <span class="o">⊹</span> <span class="n">recursiveCombination</span><span class="o">(</span><span class="n">tail</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="o">∅[</span><span class="kt">Int</span> <span class="k">=&gt;</span> <span class="kt">Boolean</span><span class="o">]</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>However, it seems like there should be an existing function to combine monoids in this way, and a little investigation reveals <code>suml</code> in <a href="https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/std/syntax/FoldableSyntax.scala">FoldableSyntax.scala</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">combined</span><span class="o">(</span><span class="n">predicates</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">*)(</span><span class="k">implicit</span> <span class="n">M</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">predicates</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">suml</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="n">combined</span><span class="o">(</span><span class="n">isDivisibleBy13</span><span class="o">,</span> <span class="n">isPalindrome</span><span class="o">,</span> <span class="n">alas</span><span class="o">)(</span><span class="n">disjunction</span><span class="o">)(</span><span class="mi">13</span><span class="o">)</span>
</span><span class='line'><span class="n">res6</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</span></code></pre></td></tr></table></div></figure>


<p>Fantastic!</p>

<p>It should be clear here that there&#8217;s nothing special about booleans in this function – they could be replaced with any other monoid and everything would keep on working. We just need to make our function generic:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">combined2</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">functions</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">*)</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">functions</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">suml</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="n">combined2</span><span class="o">(</span><span class="n">isDivisibleBy13</span><span class="o">,</span> <span class="n">isPalindrome</span><span class="o">,</span> <span class="n">alas</span><span class="o">)(</span><span class="n">disjunction</span><span class="o">)(</span><span class="mi">131</span><span class="o">)</span>
</span><span class='line'><span class="n">res7</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="n">combined2</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toString</span><span class="o">,</span> <span class="k">_</span><span class="o">.</span><span class="n">toString</span><span class="o">.</span><span class="n">reverse</span><span class="o">).</span><span class="n">apply</span><span class="o">(</span><span class="mi">123</span><span class="o">)</span>
</span><span class='line'><span class="n">res8</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="mi">123321</span>
</span></code></pre></td></tr></table></div></figure>


<p>Hopefully it&#8217;s also clear that because the only requirement of our input values is that they&#8217;re monoids, we can re‐write the above as:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">combined3</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">values</span><span class="k">:</span> <span class="kt">A*</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">values</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">suml</span>
</span></code></pre></td></tr></table></div></figure>


<p>If the introduction of monads above confused things, you&#8217;ll be happy to note that this has removed them. We can now use our <code>combined3</code> function with any monoids at all:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="o">{</span> <span class="k">implicit</span> <span class="k">val</span> <span class="n">M</span> <span class="k">=</span> <span class="n">disjunction</span><span class="o">;</span> <span class="n">combined3</span><span class="o">(</span><span class="n">isDivisibleBy13</span><span class="o">,</span> <span class="n">isPalindrome</span><span class="o">,</span> <span class="n">alas</span><span class="o">).</span><span class="n">apply</span><span class="o">(</span><span class="mi">131</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'><span class="n">res9</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="n">combined3</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="s">&quot; &quot;</span><span class="o">,</span> <span class="s">&quot;bar&quot;</span><span class="o">)</span>
</span><span class='line'><span class="n">res10</span><span class="k">:</span> <span class="kt">java.lang.String</span> <span class="o">=</span> <span class="n">foo</span> <span class="n">bar</span>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">lengthPlusOne</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">some</span>
</span><span class='line'><span class="n">lengthPlusOne</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">lengthHalved</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span><span class="o">).</span><span class="n">some</span> <span class="k">else</span> <span class="nc">None</span>
</span><span class='line'><span class="n">lengthHalved</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;three&quot;</span><span class="o">,</span> <span class="s">&quot;four&quot;</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">combined3</span><span class="o">(</span><span class="n">lengthPlusOne</span><span class="o">,</span> <span class="n">lengthHalved</span><span class="o">))</span>
</span><span class='line'><span class="n">res11</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">6</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">7</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>There we have it: a function that takes an arbitrary number of monoids, which in the case of predicates will compute their conjunction or disjunction.</p>

<h2>Bonus: Syntax</h2>

<p>One last thing: it would be nice to replicate the syntax for combining predicates from the original post. This is very simple:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">CombinablePredicate</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="o">&amp;&amp;(</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">M</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span>
</span><span class='line'>  <span class="k">def</span> <span class="o">||(</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">M</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">implicit</span> <span class="k">def</span> <span class="n">predicateToCombinablePredicate</span><span class="o">[</span><span class="kt">M</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">M</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CombinablePredicate</span><span class="o">[</span><span class="kt">M</span><span class="o">]()</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="o">&amp;&amp;(</span><span class="n">r</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">M</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="k">implicit</span> <span class="k">val</span> <span class="n">M</span> <span class="k">=</span> <span class="n">conjunction</span><span class="o">;</span> <span class="n">l</span> <span class="o">⊹</span> <span class="n">r</span> <span class="o">}</span>
</span><span class='line'>  <span class="k">def</span> <span class="o">||(</span><span class="n">r</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">M</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="k">implicit</span> <span class="k">val</span> <span class="n">M</span> <span class="k">=</span> <span class="n">disjunction</span><span class="o">;</span> <span class="n">l</span> <span class="o">⊹</span> <span class="n">r</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">1000</span><span class="o">)</span> <span class="n">filter</span> <span class="o">(</span><span class="n">isDivisibleBy13</span> <span class="o">&amp;&amp;</span> <span class="n">isPalindrome</span><span class="o">)</span>
</span><span class='line'><span class="n">res12</span><span class="k">:</span> <span class="kt">scala.collection.immutable.IndexedSeq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">494</span><span class="o">,</span> <span class="mi">585</span><span class="o">,</span> <span class="mi">676</span><span class="o">,</span> <span class="mi">767</span><span class="o">,</span> <span class="mi">858</span><span class="o">,</span> <span class="mi">949</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Given this, we can rewrite the example that initially bugged me as:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">ignorePath</span> <span class="k">=</span> <span class="n">isAssetPath</span> <span class="o">||</span> <span class="n">isMonitoringPath</span>
</span></code></pre></td></tr></table></div></figure>


<p>Success!</p>
]]></content>
  </entry>
  
</feed>
